#pragma once
#include "Core/Common.hpp"

namespace Butterfly
{
    namespace Utils
    {
        inline std::wstring StringToWString(const std::string& str)
        {
            return std::filesystem::path(str).wstring();
        }

        constexpr uint32_t Align256(uint32_t value)
        {
            return (value + 255) & ~(255);
        }

        template<typename Type>
        inline bool IsArrayPtrValid(uint32_t numElements, Type* ptr)
        {
            for (uint32_t i = 0; i < numElements; ++i)
            {
                if (ptr[i] == nullptr)
                {
                    return false;
                }
            }

            return true;
        }

        // Function is taken from this stackoverflow question about variadic templates for hash combining:
    // https://stackoverflow.com/questions/2590677/how-do-i-combine-hash-values-in-c0x
        template <typename...> struct Hasher;

        template<typename T>
        struct Hasher<T>
            : public std::hash<T>
        {
            using std::hash<T>::hash;
        };


        template <typename T, typename... Rest>
        struct Hasher<T, Rest...>
        {
            inline std::size_t operator()(const T& v, const Rest&... rest) {
                std::size_t seed = Hasher<Rest...>{}(rest...);
                seed ^= Hasher<T>{}(v)+0x9e3779b9 + (seed << 6) + (seed >> 2);
                return seed;
            }
        };

        constexpr Hasher<uint64_t> g_hasher;

        inline uint64_t Hash(uint64_t val)
        {
            return g_hasher(val);
        }

        inline void SumHash(uint64_t& in, uint64_t val)
        {
            in ^= g_hasher(val);
        }

        // Code generated by chatgpt.com
        // Prompt used "How does c++ topology sort work"
        inline std::vector<int> TopologicalSortKahn(int n, std::vector<std::vector<int>>& edges)
        {
            // Create an adjacency list representation of the graph
            std::vector<std::vector<int>> graph(n);

            // Array to store the indegree (number of incoming edges) of each node
            std::vector<int> indegree(n, 0);

            // Build the graph and calculate indegrees
            for (auto& edge : edges) {
                graph[edge[0]].push_back(edge[1]); // Directed edge from edge[0] to edge[1]
                indegree[edge[1]]++; // Increment indegree of the destination node
            }

            // Queue to store nodes with indegree 0 (ready to be processed)
            std::queue<int> q;

            // Add all nodes with indegree 0 to the queue
            for (int i = 0; i < n; i++) {
                if (indegree[i] == 0) {
                    q.push(i);
                }
            }

            int processedCount = 0; // To track the number of processed nodes

            // Vector to store the topological order
            std::vector<int> topoOrder;

            // Process nodes in the queue
            while (!q.empty()) {
                int node = q.front(); // Get the front node
                q.pop();
                topoOrder.push_back(node); // Add the node to the topological order
                processedCount++; // Increment the count of processed nodes

                // Reduce the indegree of its neighbors
                for (int neighbor : graph[node]) {
                    indegree[neighbor]--; // Remove the edge to the neighbor
                    if (indegree[neighbor] == 0) {
                        q.push(neighbor);  // Add neighbor to the queue
                    }
                }
            }

            CheckMsg(processedCount == n, "Cycle detected: topological sort not possible.");
            return topoOrder; // Return the valid topological order
        }
    }

    class NonCopyable
    {
    protected:
        NonCopyable() = default;
        ~NonCopyable() = default;
        NonCopyable(const NonCopyable&) = delete;
        NonCopyable& operator=(const NonCopyable&) = delete;
        NonCopyable(NonCopyable&&) = delete;
        NonCopyable& operator=(NonCopyable&&) = delete;
    };
}
